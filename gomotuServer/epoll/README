epoll模块的测试程序：

	epoll只是io复用的一个方式，主要作用是使一个进程或者线程同时监听多个文件描述符。
	使进程阻塞于epoll_wait而不是阻塞于io操作，然后如果被监听的描述符出现io事件就返回，然后在对描述符进行io操作。
	
	多线程io模型，是使一个线程监听一个文件描述符，不需要多路io复用的技术。

	epoll加线程池的作用主要是，接收tcp连接，监听已经连接的描述符，然后如果有io事件就调用线程池中的一个线程去处理，
	这样可以快速的处理用户的请求，减少了创建线程的时间，在多个请求同时到达后，循环的为每一个请求对应一个线程，然后就可以
	再次监听新的请求了。这种模式适用于web服务器。不适用游戏服务器。

	
	1、创建本地的tcp连接
	2、创建epoll
	3、测试ET模式和LT模式的区别
	4、测试多线程对epoll wait的影响

	测试结果：
	客户端循环的写入几千字节，epoll ET循环的读取全部字节，成功
	客户端循环的写入几千字节，epoll ET一次读取1024字节，然后不在读取，证明在ET模式下如果没有读取全部将不在响应
	由于客户端是循环的发送所以服务器接收的方式和响应是以写入的次数来算的，客户端一次写入2048字节，服务器响应一次，写入1024字
		节，这时如果不在接收服务器将不在返回，并且不会处理其他的响应。如果服务器接收了2048字节那么服务器会再次响应其他的
		写入数据。也就是说客户的一次write服务器响应一次，并且服务器最多读取一次write的数据，其他的要再次响应才可以读。
	如果服务器等待客户端读取完毕，那么就会减少响应的次数。

/*********************************************************************************************/
	epoll只是一个多路io复用的系统调用，需要了解一个源代码才可以深入的理解。

	epoll不同的搭配有不同的效果不是万能的。

	用epoll+多线程传输大文件，必然会造成时序竞态，需要加epolloneshot事件保证一个文件描述符只被一个线程使用，在读取完毕描述符
	上的数据之后，如果想要再一次得到描述符的响应需要再一次调用epoll_ctrl重新修改监听的事件。

/*********************************************************************************************/
	在经过上面的测试之后，得出结论，epoll的主要作用是使一个进程可以同时高效的使用多个文件描述符，LT与ET的区别主要是对待缓冲
	区的数据，如果一次性没有读取完毕，那么ET不会再一次触发，LT会再一次触发，与多线程结合主要是提高在循环多个文件描述符时
	处理的效率，如果怕多个线程读取一个描述符，那么就加上epolloneshot事件，但是这样需要给线程传递更多的参数，需要多调用ctrl函
	数，与多线程io相比效果一样，但是对于大量的短连接信息量较少的情况下效率较高，对于长时间的连接信息沟通量很大的情况我认为
	直接使用多线程io可能比epoll更加高效（虽然会占用很多的系统资源）。
	在测试过程中还遇到的一个问题是连续调用write对方连续read，这样的情况下何时会出现读取为空的情况，tcp保证的数据完整性是不是
	就是以write为单位的，保证一个write的数据同时到达之后才会让用户读取，而不会造成数据还在网络中传播，读取的人已经认为读取完
	毕了。

	上面问题如果想要深入的理解只做测试是没有效果的仔细读一下tcp/ip协议详解，Linux内核相关的实现可能会更加深入的理解。

	我的服务器准备开发两个版本，一个只使用多线程io，一个使用epoll加上线程池并且加上epolloneshot的约束，然后在测试两者的效率
	高低。

/+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++/
本目录文件和功能
	mainAidFun是主函数中用到的辅助函数的实现，主要有写日志、创建套接字，添加epoll fd，修改文件描述符为非阻塞。
	testLog测试日志函数的功
	threadIO是想将epoll的服务器模式改为线程io的模式
